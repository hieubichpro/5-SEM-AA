\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программы, и будет проведен сравнительный анализ реализованных алгоритмов умножения матриц по затраченному процессорному времени.

\section{Технические характеристики}

Тестирование проводилось на устройстве со следующими техническими характеристиками:

\begin{itemize}
	\item Операционная система Window 10 Home Single Language;
	\item Память 8 Гб;
	\item Процессор 11th Gen Intel(R) Core(TM) i7-1165G7 2.80 ГГц, 4 ядра.
\end{itemize}

\section{Демонстрация работы программы}

На рисунках \ref{img:demon1}, \ref{img:demon2} приведены демонстрации работы программы.
\clearpage
\img{105mm}{demon1}{Демонстрация работы программы при стандартном умножении}
\img{97mm}{demon2}{Демонстрация работы программы при умножении Винограда}
\clearpage
\section{Временные характеристики}

Результаты эксперимента замеров по времени приведены в таблицах~\ref{tbl:even_time},~\ref{tbl:odd_time}.

В таблице~\ref{tbl:even_time} приведены результаты замеров по времени алгоритмов умножения матриц при четных размеров квадратных матриц от 1 до 100 с шагом 10 на различных входных данных. 

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Результаты замеров времени (чётные размеры матриц)}
			\label{tbl:even_time}
			\begin{tabular}{|c|c|c|c|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Время, мс} \\ \cline{2-4}
				\bfseries Размер матрицы & \bfseries Классический & \bfseries Винограда & \bfseries (опт.) Винограда
				\csvreader{csv/memory.csv}{} 
				{\\\hline \csvcoli & \csvcolii & \csvcoliii & \csvcoliv} \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}
По таблице~\ref{tbl:even_time} был построен график \ref{img:even}. Исходя из этих данных можно понять, что лучшего всего работает оптимизированный алгоритм Винограда, а классический алгоритм работаем в 1,3 раз хуже, чем алгоритм Винограда.

\clearpage

\img{120mm}{even}{Сравнение по времени алгоритмов умножения матриц на чётных размерах матриц}

В таблице~\ref{tbl:odd_time} приведены результаты замеров по времени алгоритмов умножения матриц при нечетных размеров квадратных матриц, размеров от 1 до 101 с шагом 10 на различных данных.
\clearpage
\begin{table}[ht]
	\begin{center}
		\begin{threeparttable}
			\small
			\caption{Результаты замеров времени (нечётные размеры матриц)}
			\label{tbl:odd_time}
			\begin{tabular}{|c|c|c|c|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Время, мс} \\ \cline{2-4}
				\bfseries Размер матрицы & \bfseries Классический & \bfseries Винограда & \bfseries (опт.) Винограда
				\csvreader{csv/odd.csv}{}
				{\\\hline \csvcoli & \csvcolii & \csvcoliii & \csvcoliv} 
				\\
				\hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}

По таблице \ref{tbl:odd_time} был построен график \ref{img:odd}. Исходя из этих данных можно понять, что лучшего всего работает оптимизированный алгоритм Винограда, а классический алгоритм работаем в 1,2 раз хуже, чем алгоритм Винограда.

\clearpage

\img{120mm}{odd}{Сравнение по времени алгоритмов умножения матриц на нечётных размерах матриц}

\clearpage

\section {Характеристики по памяти}
Пусть M - количество строк первой матрицы, N - количество столбцов первой матрицы, Q - количество столбцов второй матрицы, тогда затраты памяти на рассматриваемые алгоритмы будут следующими.

Стандартный алгоритм умножения матриц:
\begin{itemize}[label=---]
	\item размер матрицы --- 3 $\cdot$ sizeof(size\_t);
	\item матрица --- (M $\cdot$ N + N $\cdot$ Q) $\cdot$ sizeof(int)
\end{itemize}
Таким образом, общая затраченная память в стандартном алгоритме умножения матриц равна  $4 \cdot M \cdot N + 4 \cdot N \cdot Q + 3 \cdot 8 = 4 \cdot M \cdot N + 4 \cdot N \cdot Q + 24$.

Алгоритм Винограда:
\begin{itemize}[label=---]
	\item размер матрицы --- 3 $\cdot$ sizeof(size\_t);
	\item вспомогательная переменная --- sizeof(size\_t);
	\item вспомогательные матрицы --- (M + Q) $\cdot$ sizeof(int);
	\item матрица --- (M $\cdot$ N + N $\cdot$ Q) $\cdot$ sizeof(int).
\end{itemize}
Таким образом, общая затраченная память в алгоритме Винограда равна $3 \cdot 8 + 1 \cdot 8 + (M + Q) \cdot 4 + 4 \cdot M \cdot N + 4 \cdot N \cdot Q = 4 \cdot M \cdot N + 4 \cdot N \cdot Q + 4 \cdot M + 4 \cdot Q + 32$.

Оптимизированный алгоритм Винограда:
\begin{itemize}[label=---]
	\item размер матрицы --- 3 $\cdot$ sizeof(size\_t)
	\item вспомогательная переменная --- 1 $\cdot$ sizeof(size\_t) + 1 $\cdot$ sizeof(int)
	\item вспомогательные матрицы --- (M + Q) $\cdot$ sizeof(int),
	\item матрица --- (M $\cdot$ N + N $\cdot$ Q) $\cdot$ sizeof(int)
\end{itemize}
Таким образом, общая затраченная память в алгоритме оптимизированного Винограда равна $3 \cdot 8 + 1 \cdot 8 + 1 \cdot 4 + (M + Q) \cdot 4 + 4 \cdot M \cdot N + 4 \cdot N \cdot Q = 4 \cdot M \cdot N + 4 \cdot N \cdot Q + 4 \cdot M + 4 \cdot Q + 36$.

Результаты расчетов памяти, которых представлены в таблице \ref{tbl:memory}, где размеры матриц находятся в диапазоне от 1 до 100 с шагом 10.

\begin{table}[ht]
	\begin{center}
		\begin{threeparttable}
			\small
			\caption{Результаты замеров памяти}
			\label{tbl:memory}
			\begin{tabular}{|c|c|c|c|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Память, байт} \\ \cline{2-4}
				\bfseries Размер матрицы & \bfseries Классический & \bfseries Винограда & \bfseries (опт.) Винограда
				\csvreader{csv/memory.csv}{}
				{\\\hline \csvcoli & \csvcolii & \csvcoliii & \csvcoliv} 
				\\
				\hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}

По таблице \ref{tbl:memory} был построен график \ref{img:memory}. Исходя из этих данных можно понять, что стандартный алгоритм потребляет меньше всего памяти, также алгоритм Винограда и оптимизированный алгоритм Виноград используют примерно одинаковое количество памяти.

\clearpage

\img{100mm}{memory}{Сравнение по памяти алгоритмов умножения матриц}

\clearpage

\section{Вывод}

В результате эксперимента было получено, что при размере матриц, большем 40, оптимизированный алгоритм Винограда работает быстрее стандартного алгоритма в 1.45 раза. При этом стандартный алгоритм медленнее алгоритма Винограда в 1.3 раза. Тогда, для размера матриц, начиная с 40 элементов, небходимо использовать оптимизированный алгоритм умножения матриц по Винограду. Стандартный алгоритм использует меньше всего памяти. Затрата памяти алгоритма Винограда и его оптимизированной версии немного различается. 

Также в результате эксперимента было установлено, что при четном размере матриц, алгоритм Винограда работает быстрее, чем на матрицах с нечетным размером в 1.08 раза в связи с проведением дополнительных вычислений для крайних строк и столбцов. Можно сделать вывод, что алгоритм Винограда предпочтительно использовать для умножения матриц четных размеров.