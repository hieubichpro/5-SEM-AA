\chapter{Исследовательская часть}

В данном разделе будут приведены демонстрации работы программы, и будет проведен сравнительный анализ реализованных алгоритмов сортировок по времени и по памяти.

\section{Технические характеристики}

Тестирование проводилось на устройстве со следующими техническими характеристиками:

\begin{itemize}
	\item операционная система Window 10 Home Single Language;
	\item память 8 Гб;
	\item процессор 11th Gen Intel(R) Core(TM) i7-1165G7 2.80 ГГц, 4 ядра.
\end{itemize}

\section{Демонстрация работы программы}

На рисунках \ref{img:demon1}--\ref{img:demon3} представлен результат работы программы. В каждом примере пользователем введен массив целых чисел и получены результаты его сортировки.

\img{40mm}{demon1}{Демонстрация работы программы при бисерной сортировке}
\img{40mm}{demon2}{Демонстрация работы программы при поразрядной сортировке}
\img{40mm}{demon3}{Демонстрация работы программы при сортировке бинарным деревом}
\clearpage


\section{Результаты замера процессорного времени}

Результаты эксперимента замеров по времени приведены в таблицах~\ref{tbl:random},~\ref{tbl:reverse_sorted}.

В таблице~\ref{tbl:random} приведены результаты замеров по времени алгоритмов сортировок неотсортированных массивов (это условие наступления лучшего случая сортировки бинарным деревом), размер которых варьируется от 1 до 2500 с шагом 250. 

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Результаты замеров времени (неотсортированные массивы)}
			\label{tbl:random}
			\begin{tabular}{|c|c|c|c|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Время, мс} \\ \cline{2-4}
				\bfseries Размер массива & \bfseries Бусинами & \bfseries Поразрядная & \bfseries Бинарным деревом
				\csvreader{csv/random.csv}{} 
				{\\\hline \csvcoli & \csvcolii & \csvcoliii & \csvcoliv} \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

По таблице~\ref{tbl:random} был построен график, который иллюстрирует зависимость процессорного времени, затраченного реализациями алгоритмов сортировки, от размера массива --- рис.~\ref{img:random}.
Исходя из этих данных можно понять, что лучшего всего работает поразрядная сортировка, а бисерная сортировка работает в 5,6 раз хуже, чем алгоритм сортировки бинарным деревом.

\clearpage

\img{120mm}{random}{Сравнение по времени алгоритмов сортировок на неотсортированных массивах}


В таблице~\ref{tbl:sorted} приведены результаты замеров по времени алгоритмов сортировок отсортированных массивов (это условие наступления худшего случая сортировки бинарным деревом) по возрастанию, размер которых варьируется от 1 до 2500 с шагом 250. 

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Результаты замеров времени (отсортированные миссивы по возрастанию)}
			\label{tbl:sorted}
			\begin{tabular}{|c|c|c|c|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Время, мс} \\ \cline{2-4}
				\bfseries Размер массива & \bfseries Бусинами & \bfseries Поразрядная & \bfseries Бинарным деревом
				\csvreader{csv/sorted.csv}{} 
				{\\\hline \csvcoli & \csvcolii & \csvcoliii & \csvcoliv} \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}
\clearpage
По таблице~\ref{tbl:sorted} был построен график, который иллюстрирует зависимость процессорного времени, затраченного реализациями алгоритмов сортировки, от размера массива --- рис.~\ref{img:sorted}. Исходя из этих данных можно понять, что лучшего всего работает алгоритм поразрядной сортировки, времени выполнения алгоритма сортировки бинарным деревом увеличивается в 1,2 раза из-за несбалансированного дерева.

%\clearpage

\img{120mm}{sorted}{Сравнение по времени алгоритмов сортировок на отсортированных массивах по возрастанию}

В таблице~\ref{tbl:reverse_sorted} приведены результаты замеров по времени алгоритмов сортировок отсортированных массивов (это условие наступления худшего случая сортировки бинарным деревом) по возрастанию, размер которых варьируется от 1 до 2500 с шагом 250.

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Результаты замеров времени (отсортированные миссивы по убыванию)}
			\label{tbl:reverse_sorted}
			\begin{tabular}{|c|c|c|c|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Время, мс} \\ \cline{2-4}
				\bfseries Размер массива & \bfseries Бусинами & \bfseries Поразрядная & \bfseries Бинарным деревом
				\csvreader{csv/reverse_sorted.csv}{} 
				{\\\hline \csvcoli & \csvcolii & \csvcoliii & \csvcoliv} \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}
\clearpage
По таблице~\ref{tbl:reverse_sorted} был построен график, который иллюстрирует зависимость процессорного времени, затраченного реализациями алгоритмов сортировки, от размера массива --- рис.~\ref{img:reverse_sorted}.
Исходя из этих данных можно понять, что лучшего всего работает поразрядная сортировка, самая медленная --- сортировка бисунами.

\img{120mm}{reverse_sorted}{Сравнение по времени алгоритмов сортировок на отсортированных массивах по убыванию}

\section{Характеристики по памяти}

Пусть N --- количество элементов массива, M --- максимальное значение массива, тогда затраты памяти на рассматриваемые алгоритмы будут следующими.

Бисерная сортировка:
\begin{itemize}[label=---]
	\item размер массива --- 1 $\cdot$ sizeof(size\_t);
	\item вспомогательные переменные --- 3 $\cdot$ sizeof(int);
	\item вспомогательные массивы --- (N + M) $\cdot$ sizeof(int).
\end{itemize}
Таким образом, общая затраченная память в бисерной сортировке равна  $1 \cdot 8 + 3 \cdot 4 + (N + M) \cdot 4 = 4M + 4N + 20$.

Поразрядная сортировка:
\begin{itemize}[label=---]
	\item размер массива --- 1 $\cdot$ sizeof(size\_t);
	\item вспомогательные переменные --- 2 $\cdot$ sizeof(int);
	\item вспомогательные массивы --- (N + 10) $\cdot$ sizeof(int).
\end{itemize}
Таким образом, общая затраченная память в поразрядной сортировке равна  $1 \cdot 8 + 2 \cdot 4 + (N + 10) \cdot 4 = 4N + 56$.

Сортировка бинарным деревом:
\begin{itemize}[label=---]
	\item размер массива --- 1 $\cdot$ sizeof(size\_t);
	\item размер подов --- $\log(N)$ $\cdot$ sizeof(Node);
	\item вспомогательный массив --- N $\cdot$ sizeof(int).	
\end{itemize}
Таким образом, общая затраченная память в сортировке бинарным деревом равна $1 \cdot 8 + \log(N) \cdot 12 + N \cdot 4 = 4N + 12\log(N) + 8$.

Результаты расчетов памяти, которых представлены в таблице \ref{tbl:memory}, где размеры массивов находятся в диапазоне от 1 до 2500 с шагом 250.
\begin{table}[ht]
	\begin{center}
		\begin{threeparttable}
			\small
			\caption{Результаты замеров памяти}
			\label{tbl:memory}
			\begin{tabular}{|c|c|c|c|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Память, кб} \\ \cline{2-4}
				\bfseries Размер массива & \bfseries Бусинами & \bfseries Поразрядная & \bfseries Бинарным деревом
				\csvreader{csv/memory.csv}{}
				{\\\hline \csvcoli & \csvcolii & \csvcoliii & \csvcoliv} 
				\\
				\hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}
\clearpage
По таблице \ref{tbl:memory} был построен график, который иллюстрирует зависимость памяти, затраченного реализациями алгоритмов сортировки, от размера массива --- рис.~\ref{img:memory}.
Исходя из этих данных можно понять, что бисерная сортировка потребляет больше всего памяти, также алгоритм поразрядной сортировки и алгоритм сортировки бинарным деревом используют примерно одинаковое количество памяти.

\img{100mm}{memory}{Сравнение по памяти алгоритмов сортировок}

\section{Вывод}
Характер зависимости процессорного времени выполнения реализаций алгоритмов сортировки от размера массива совпал с рассчитанными функциями трудоёмкости.
В результате эксперимента было получено, что при размере массива больше 500 поразрядная сортировка работает быстрее сортировки бинарным деревом в 20 раза.
При этом бисерная сортировка работает медленнее сортировка бинарным деревом в 8.9 раза.
В случае, если массив уже отсортирован, время выполнения сортировки бинарным деревом в 1.3 раза увеличивается из-за несбалансированного дерева.

При размере массива больше 500 бисерная сортировка использует памяти в 4,5 раза больше остальных.
При этом поразрядная сортировка и сортировка бинарным деревом используют примерно одинаковое количество памяти.