\chapter{Исследовательская часть}

В данном разделе приводятся результаты замеров затрат реализаций алгоритмов по памяти и времени.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялись замеры:

\begin{itemize}
	\item[---] Операционная система Window 10 Home Single Language;
	\item[---] Память 8 Гб;
	\item[---] Процессор 11th Gen Intel(R) Core(TM) i7-1165G7 2.80 ГГц, 4 ядра.
\end{itemize}

\section{Время выполнения реализаций алгоритмов}

Процессорное время реализаций алгоритмов замерялось при помощи функции process\_time() из библиотеки time языка Python. Данная функция возвращает количество секунд, прошедших с начала эпохи, типа float.

Замеры времени для каждой длины слов проводились 5000 раз. В качестве результата взято среднее время работы алгоритма на данной длине слова. При каждом запуске алгоритма, на вход подавались случайно сгенерированные строки, днины строк (Length).

Результаты замеров приведены на рисунке \ref{img:time_measure} (в микросекундах).

\img{75mm}{time_measure}{Результаты замеров времени (в микросекундах)}
\newpage

Сранение время выполнения между алгоритмами Левенштейн и Дамерау-Леиенштейн (нерекурсивно) на рисунке \ref{img:lev-levdam}
 
\img{75mm}{lev-levdam}{Результаты сравнения Левенштейн и Дамерау-Левенштейн (в микросекундах)}


Сранение время выполнения между тремя алгоритмами Дамерау-Леиенштейн на рисунке \ref{img:damlev}
\img{75mm}{damlev}{Результаты сравнения трех алгоритмов Дамерау-Левенштейн (в микросекундах)}

\img{75mm}{mat_cache}{Результаты сравнения Дамерау-Левенштейна(матричный) и Дамерау-Левенштейна(с кэшем)}

\newpage

\section*{Вывод}

В результате замеров можно прийти к выводу, что матричная реализация алгоритмов нахождения расстояний заметно выигрывает по времени при росте строк.

\section{Затраты памяти выполнения реализаций алгоритмов}

Пусть длина строки S1 --- n, длина строки S2 --- m, тогда затраты памяти на приведенные  алгоритмы будут следующими.

Матричный алгоритм поиска расстояния Левенштейна:
\begin{itemize}
    \item[---] строки S1, S2 --- (m + n) $\cdot$ sizeof(char),
    \item[---] матрица --- ((m + 1) $\cdot$ (n + 1)) $\cdot$ sizeof(int),
    \item[---] длины строк --- 2 $\cdot$ sizeof(int),
\end{itemize}

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк.

Рекурсивный алгоритм поиска расстояния Дамерау -- Левенштейна (для каждого вызова):
\begin{itemize}
    \item[---] строки S1, S2 --- (m + n) $\cdot$ sizeof(char),
    \item[---] длины строк --- 2 $\cdot$ sizeof(int),
    \item[---] размер аргументов функции --- 2 $\cdot$ 24,
    \item[---] размер адреса возврата --- 4.
\end{itemize}

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк. Таким образом, общая затраченная память в рекурсивном алгоритме будет равна $m + n + (2 \cdot 4 + 2 \cdot 24 + 4) \cdot (n + m) = 61\cdot m + 61\cdot n$.

Рекурсивный алгоритм поиска расстояния Дамерау -- Левенштейна с использованием кеша (для каждого вызова): 

\begin{itemize}
    \item[---] Для всех вызовов память для хранения самой матрицы ---  ((m + 1) $\cdot$ (n + 1)) $\cdot$ sizeof(int),
    \item[---] строки S1, S2 --- (m + n) $\cdot$ sizeof(char),
    \item[---] длины строк --- 2 $\cdot$ sizeof(int),
    \item[---] вспомогательные переменные ---  1 $\cdot$ sizeof(int),
    \item[---] размер аргументов функции --- 2 $\cdot$ 24,
    \item[---] ссылка на матрицу --- 8 байт,
    \item[---] размер адреса возврата --- 4.
\end{itemize}
	
Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк. Таким образом, общая затраченная память в рекурсивном алгоритме будет равна $m + n + 4 \cdot (m + 1) \cdot (n + 1) + (2 \cdot 4 + 4 + 4 + 2 \cdot 24) \cdot (n + m) = 4\cdot m\cdot n + 69\cdot m + 69\cdot n + 4$.

Матричный алгоритм поиска расстояния Дамерау -- Левенштейна: 
\begin{itemize}
    \item[---] строки S1, S2 --- (m + n) $\cdot$ sizeof(char),
    \item[---] матрица --- ((m + 1) $\cdot$ (n + 1)) $\cdot$ sizeof(int),
    \item[---] длины строк --- 2 $\cdot$ sizeof(int),
    \item[---] вспомогательные переменные --- 3 $\cdot$ sizeof(int).
\end{itemize}

Таким образом, общая затраченная память в рекурсивном алгоритме будет равна $m + n + 4 \cdot (m + 1) \cdot (n + 1) + 6 \cdot 4 = 4\cdot m\cdot n + 5\cdot m + 5\cdot n + 28$.

\img{75mm}{memory}{Результаты замеров памяти(в байтах)}

\section{Вывод}

В результате можно прийти к выводу, что матричная реализация алгоритмов нахождения расстояний заметно выигрывает по памяти при росте строк.